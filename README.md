# Для запуска

```sh
npm i
npm run server
npm start
```

Будет запущен dev сервер на адрес localhost:8080

*Либо можно открыть файл public/index.html*

# Шаблонизатор
Для задания мною был выбрана библиотека React. Это позволило мне сконцентрироваться на самой верстке, а не на решении проблемы с шаблонами.

Так как, у меня был готовый конфиг вебпка, знания по React, а так же удобная работа с горячей перезагрузкой, я остановился на этом решении.

Для генерации css использованы CSS Modules https://habr.com/post/270103/

Они позволяют упростить генерацию имён стилей (каждый класс имеет свои уникальные имена за счет хешей), а так же упрощают работу с изменением состояния компанента за счет composes.

# Структура проекта

* public - итог сборки build + иконки и лицензия
* src - исходный код
* src\components - компоненты реакта по папкам. Папка, jsx и css файл одного компонента имеют одинаковое название для упрощения навигации в проекте. В компаненте может быть папка img с картинками под этот компонент.
* src\css - константы для css
* src\helpers - хелперы для js кода (бизнес логика вынесенная из компонентов).
* src\index.html - шаблон для html для проекта
* src\index.js - точка входа в приложение (рендер реакта в дом дерево).
* data\events.json - данные из ТЗ по адаптивной верстке
* data\cams.json - данные для камер по мультимедия
* server - исходный код сервера

Корневой компонент - App.

## Первое задание

Адаптацию производил под разрешения телефона, планшета, ноутбука и широкоформатного монитора (дополнительные колонки).

Дополнительно сделал адаптивную типографику (через media изменение размера шрифтов в px)

Адаптивные изображения сделал через img srcset.

Вариантивные шрифты не делал.


## Второе задание
Второе задание реализовано в этом же проекте. Для исключения влияния реакта на события pointer (сугубо для домашнего задания) использовано ручное навешивание в ComponentDidMount компонента Card.

Реализацию логики жестов вынес в файл src\helpers\gestures.js

Когда делал второе задание, изначально использовал другую картинку и background-image. Реализовал Pointer Lock Api, но при интеграции в первое задание пришлось отказаться от background, так как картинка сделана через img для адаптивности. В итоге от pointer lock api отказался в итоговой реализации.

## Третье задание
Сервер с потоками видео был опубликован на heroku, поэтому для запуска проекта и просмотра результата поднимать дополнительно сервер не нужно.

Анимация открытия видео сделана через transform scale.

Звук в диаграмме выводится в логарифмической шкале, так как так более принято показывать звуковую диаграмму. Анализатор звука находится в файле src/helpers/AudioAnalyser.js, визуализация в BarDiagram.

Основной компонент для анимации src/components/Video/Video.jsx. Так же для решения этой задачи используются компоненты VideoPlayer, VideoControls, BarDiagram.

Реализована логика для изменения размера страницы, при открытом видео (например, смена ориентации в мобильном версии).

Тестировалось на Opera, как на десктопе, так и на телефоне.

Навигация между страницами сделана через react router

Страница с камерами сделана в визуальном стиле страницы событий.
Адрес страницы http://localhost:8080/#/cams (либо через навигационное меню)

На данной ветке собран актуальный билд, возможен запуск без дев сервера и установки пакетов. public/index.html/#/cams

### Детектор движения
Для детектора используется алгоритм сравнения пикселей.
Доступные настройки:
- Пропуск кадров - как частно будет сбор данных для алгоритма движения. Чем больше, тем реже производится анализ.
- Кадров для анализа - сколько последних кадров взятых в алгоритм будут анализироваться с последним. Больше - лучше срабатывания, но могут появится шлейфы на быстрых объектах.
- Точность по X\Y - как частно алгоритм анализирует пиксели. 1 - каждый пиксель, 10 - каждый десятый. Меньше - точнее анализ.
- Погрешность - уровень допустимого изменения пикселя, что бы он не распознался алгоритмом. Нужно для устранения шумов на видео. Меньше точнее анализ, но больше ложных срабатываний.

При указании настроек производится расчет сложности. На i5 2.6 GHz сложность около 1000к позволяла рендерить видео в  60fps. Чем больше сложность, тем сложнее анализ и больше шанс по просадке фпс.

Настройки следует подбирать на основании источника видео. Например, на видео с собакой хорошо подходят настройки - пропуск: 1, кадров для анализа 3, точность X\Y: 1, погрешность 70.
Из за скорости собаки количество кадров для анализа можно снизить, что бы не было большого прямоугольника, а точность нужно повысить, так как собака очень маленькая на экране.

## Четвертое задание

Для запуска сервера
* npm run server обычный старт сервера
* npm run server-dev для запуска в nodemon режиме.

Сервер запускается на 8000 порту

Клиентская часть подключена к серверу http://localhost:8000

Реализованы get запросы:
* /status
* /api/events
* /api/cams

Реализованы post запросы:
* /api/events (параметры в json формате)
* /api/cams/settings (параметры в json формате)

/api/events поддерживает параметры: type (разделить двоеточие), offset, limit

*Примеры:*

    * GET http://localhost:8000/status - 00:00:42

    * GET http://localhost:8000/api/events

    * GET http://localhost:8000/api/events?type=info:critical:bobo:asdf - ошибка 400

    * GET http://localhost:8000/api/events?type=info:critical

    * GET http://localhost:8000/api/events?type=critical

    * GET http://localhost:8000/api/events?type=info&limit=6

    * GET http://localhost:8000/api/events?type=info:critical&offset=3&limit=25

    * GET http://localhost:8000/api/events?type=info:critical&offset=3&limit=2

    * GET http://localhost:8000/api/events?offset=8

    * GET http://localhost:8000/api/events?type=critical&offset=8

    * POST http://localhost:8000/api/events

    Content-Type: application/json

    {
      "type": "critical",
      "offset": 2
    }

    * GET http://localhost:8000/api/cams

    * GET http://localhost:8000/api/asdf - ошибка 404

    * POST http://localhost:8000/api/cams/settings

    Content-Type: application/json

    {
      "url": "https://shri-smart-house.herokuapp.com/cat%2Fmaster.m3u8",
      "settings": {"contrast": 0.35}
    }

## Типизация
Для запуска проекта подходят команды описанные в самом начале readme.

Реализовал всё из раздела преимуществ:

- отсутствие явных и неявных типов any
- компиляция в строгом режиме ("strict": true в tsconfig.json)
- отсутствие // @ts-ignore, использования оператора ! для подавления ошибок строгих проверок на null
- минимальное использование type assertions, как например someVar as SomeType
- использование tslint

Запуск Node.js сервера происходит через ts-node

Так как в проекте был использован webpack, компиляция клиентской части происходит посредством ts-loader

#### 1. Сложности во время перевода

- ts-loader по умолчанию проверял все файлы *.ts, что сильно мешало поэтапному переводу проекта. Повезло, что это отключается.

- Сложно было свыкнутся с мыслью, что typescript не понимает жизненых циклов React и приходится многократно проверять на null,  в тех местах которые не могли возникнуть из за последовательности выполнения кода. Например, componentDidMount объявляет переменную класса и она никогда не чистится. Любой вызов функций подразумевается после componentDidMount, но поскольку ts этого не знает, приходится делать много лишних движений.

- Так же не удобны моменты, что ts плохо понимает контекст вызова функций. Была функция вызываемая в конструкторе и инициализирующая часть переменных (что бы конструктор не был большим). Для ts такая функция не является частью конструктора и вылетают ошибки, что у переменных в конструкторе не назначены значения.

- Если сделать проверку на null и вызвать после функцию, то во вложенной функции опять придется проверять на null, хотя функция не может быть вызвана, если переменная null.

- Нет опыта и понимания, как и куда складывать интерфейсы. Что-то подсказывает, что это должны быть отдельные файлы. Сделал пока внутри кода, где эти интерфейсы используются.

- Печалит использование большого количества пакетов, для типизации уже установленных пакетов (@types/)

#### 2. Какие в процессе перевода были найдены ошибки

В процессе перевода ошибок выявлено не было.

#### 3. Решили ли вы вливать данный PR, или предпочитаете работать с JavaScript? Почему?

Я продолжу использовать TypeScript. Причины:

1. До web разработки у меня был опыт работы с типизированными языками и отсутствие этого при переходе в web было болью.

2. Я нахожусь в школе, выделяю время на обучение. Разово перевести проект это хорошо, но уметь выполнять поставленные задачи на TypeScript это лучше. Поэтому, использование TypeScript будет как дополнительное обучение.

3. Типизация это просто круто.


## Контакты

Доступен в телеграме по нику @KingManiya